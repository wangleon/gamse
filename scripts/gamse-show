#!/usr/bin/env python3
import os
import argparse
import configparser

import numpy as np
import astropy.io.fits as fits
import matplotlib.pyplot as plt
import matplotlib.ticker as tck

from gamse.utils.obslog import read_obslog

def show_onedspec():
    """Show 1-D spectra in a pop-up window.
    """

    # load obslog
    logname_lst = [fname for fname in os.listdir(os.curdir)
                        if fname.endswith('.obslog')]
    if len(logname_lst)==0:
        logtable = None
    else:
        logtable = read_obslog(logname_lst[0])


    # load config files in the current directory
    config_file_lst = [fname for fname in os.listdir(os.curdir)
                        if fname.endswith('.cfg')]
    config = configparser.ConfigParser(
                inline_comment_prefixes = (';','#'),
                interpolation           = configparser.ExtendedInterpolation(),
                )
    config.read(config_file_lst)


    parser = argparse.ArgumentParser()
    parser.add_argument('-o', '--order', help='physical order to plot')
    parser.add_argument('filenames', nargs='+', help='files to be plotted')
    args = parser.parse_args()


    filename_lst = []
    for arg in args.filenames:
        # first, check if argument is a filename.
        if os.path.exists(arg):
            filename_lst.append(arg)
        elif arg.isdigit() and obslog is not None:
            # if arg is a number, find the corresponding filename in obslog
            arg = int(arg)
            section = config['reduce']
            for logitem in logtable:
                if arg == logitem['frameid']:
                    # get the path to the 1d spectra
                    odspath = section.get('odspath', None)
                    if odspath is None:
                        odspath = section.get('oned_spec')

                    # get the filename suffix for 1d spectra
                    oned_suffix = config['reduce'].get('oned_suffix')

                    fname = '{}_{}.fits'.format(logitem['fileid'], oned_suffix)
                    filename = os.path.join(odspath, fname)
                    if os.path.exists(filename):
                        filename_lst.append(filename)
                    break
        else:
            print('File "" does not exists'.format(arg))

    if len(filename_lst)==0:
        print('Nothing to plot')
        exit()

    spec_lst = []
    for filename in filename_lst:
        data = fits.getdata(filename)

        # determine the column name of flux that will be shown
        if 'flux' in data.dtype.names:
            flux_key = 'flux'
        elif 'flux_sum' in data.dtype.names:
            flux_key = 'flux_sum'
        else:
            flux_key = ''
            pass

        if 'fiber' in data.dtype.names:
            # multi fiber
            for fiber in np.unique(data['fiber']):
                spec = {}
                mask = data['fiber']==fiber
                for row in data[mask]:
                    order = row['order']
                    wave  = row['wavelength']
                    flux  = row[flux_key]
                    spec[order] = (wave, flux)
                label = os.path.basename(filename) + ' Fiber {}'.format(fiber)
                spec_lst.append((spec, label))
        else:
            spec = {}
            for row in data:
                order = row['order']
                wave  = row['wavelength']
                flux  = row[flux_key]
                spec[order] = (wave, flux)
            label = os.path.basename(filename)
            spec_lst.append((spec, label))
    
    ################################################

    fig = plt.figure(figsize=(15, 8), dpi=150)
    ax = fig.add_axes([0.07, 0.1, 0.88, 0.8])

    def plot_order(order):
        ax.cla()
        ax.currentorder = order
        wave_min, wave_max = 1e9, 0
        flux_min = 1e9
        for i, (spec, label) in enumerate(spec_lst):
            if order in spec:
                wave = spec[order][0]
                flux = spec[order][1]
                ax.plot(wave, flux, '-', alpha=0.8, lw=0.8, label=label)
                wave_min = min(wave_min, wave.min())
                wave_max = max(wave_max, wave.max())
                flux_min = min(flux_min, flux.min())
        leg = ax.legend(loc='upper right')
        leg.get_frame().set_alpha(0.1)
        ax.set_xlabel(u'Wavelength (\xc5)', fontsize=12)
        ax.set_ylabel('Flux', fontsize=12)
        ax.set_title('Order %d'%(order), fontsize=14)
        ax.set_xlim(wave_min, wave_max)
        ax.axhline(y=0, color='k', ls='--', lw=0.5)
        if flux_min > 0:
            ax.set_ylim(0,)
        ax.xaxis.set_major_formatter(tck.FormatStrFormatter('%g'))
        ax.yaxis.set_major_formatter(tck.FormatStrFormatter('%g'))
        fig.canvas.draw()

    def on_key(event):
        if event.key == 'up':
            can_plot = False
            for spec, label in spec_lst:
                if ax.currentorder + 1 in spec:
                    can_plot=True
                    break
            if can_plot:
                plot_order(ax.currentorder + 1)
        elif event.key == 'down':
            can_plot = False
            for spec, label in spec_lst:
                if ax.currentorder - 1 in spec:
                    can_plot=True
                    break
            if can_plot:
                plot_order(ax.currentorder - 1)
        else:
            pass

    # find the order to be plotted
    if args.order is None:
        # no specified, use the first order of the first spec
        spec = spec_lst[0][0]
        porder = list(spec.keys())[0]
    elif args.order.isdigit():
        # order numbers is given. Find the corresponding order if exists
        find = False
        for spec, label in spec_lst:
            if int(args.order) in spec:
                porder = int(args.order)
                find = True
                break
        if not find:
            porder = list(spec.keys())[0]
            print(('The user specified order {} is not in the plotted spectra. '
                   'Plot order {} instead').format(args.order, porder))
    elif args.order in ['r', 'red']:
        # plot the reddest order
        porder = min([min(spec.keys()) for spec,label in spec_lst])
    elif args.order in ['b', 'blue']:
        # plot the reddest order
        porder = max([max(spec.keys()) for spec,label in spec_lst])
    else:
        print('Cannot understand order {}'.format(args.order))
        porder = list(spec.keys())[0]

    plot_order(porder)

    fig.canvas.mpl_connect('key_press_event', on_key)
    plt.show()

if __name__=='__main__':
    show_onedspec()
